import discord
from discord.ext import commands
from discord import app_commands
from keep_alive import keep_alive
import re
import json
import os


# Ativando os intents necessÃ¡rios
intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.members = True

bot = commands.Bot(command_prefix="!", intents=intents)

DATA_FILE = "data.json"
user_counters = {}

# ---------------- FunÃ§Ãµes de salvar/carregar ----------------
def load_data():
    if os.path.exists(DATA_FILE):
        try:
            with open(DATA_FILE, "r") as f:
                data = json.load(f)
                if isinstance(data, dict) and data:  # garante que Ã© dict e nÃ£o estÃ¡ vazio
                    return data
        except Exception as e:
            print(f"âš ï¸ Erro ao carregar data.json: {e}")
    return {}  # retorna vazio se nÃ£o houver dados vÃ¡lidos


def save_data():
    # SÃ³ salva se houver dados no dicionÃ¡rio
    if user_counters:
        with open(DATA_FILE, "w") as f:
            json.dump(user_counters, f, indent=4)
        print("ğŸ’¾ Dados salvos em data.json")
    else:
        print("âš ï¸ Nenhum dado para salvar, nÃ£o sobrescrevendo data.json")
# -------------------------------------------------------------


@bot.event
async def on_ready():
    global user_counters
    loaded_data = load_data()
    if loaded_data:  # sÃ³ substitui se houver dados vÃ¡lidos
        user_counters = loaded_data
        print("âœ… Dados carregados do data.json")
    else:
        print("âš ï¸ Nenhum dado vÃ¡lido encontrado em data.json (mantendo contador vazio).")

    print(f"ğŸ¤– Bot conectado como {bot.user}")
    try:
        synced = await bot.tree.sync()
        print(f"ğŸ“Œ Comandos de barra sincronizados: {len(synced)}")
    except Exception as e:
        print(f"âŒ Erro ao sincronizar comandos: {e}")


#------------COMANDOS

#COMANDO TK
@bot.event
async def on_message(message):
    if message.author.bot:
        return

    # Novo padrÃ£o: @culpado tk @vitima
    pattern = r"<@!?(\d+)>\s+tk\s+<@!?(\d+)>"
    matches = re.findall(pattern, message.content, flags=re.IGNORECASE)

    for culpado_id_str, vitima_id_str in matches:
        culpado_id = int(culpado_id_str)
        vitima_id = int(vitima_id_str)

        # Atualiza contador do culpado
        if str(culpado_id) in user_counters:
            user_counters[str(culpado_id)] += 1
        else:
            user_counters[str(culpado_id)] = 1

        save_data()

        culpado_user = await bot.fetch_user(culpado_id)
        vitima_user = await bot.fetch_user(vitima_id)

        await message.channel.send(
            f"ğŸ’¥ {culpado_user.mention} deu TK em {vitima_user.mention}! "
            f"Agora ele jÃ¡ tem {user_counters[str(culpado_id)]} teamkills! "
            f"A Escola Lozenilson de TK estÃ¡ orgulhosa!"
        )

    await bot.process_commands(message)


# COMANDO /CONTADOR

# Ver contador de 1 usuÃ¡rio
@bot.tree.command(name="contador", description="Veja quantos teamkills um usuÃ¡rio cometeu.")
@app_commands.describe(usuario="UsuÃ¡rio que vocÃª quer ver o contador")
async def contador(interaction: discord.Interaction, usuario: discord.User):
    count = user_counters.get(str(usuario.id), 0)
    await interaction.response.send_message(
        f"ğŸ“Š {usuario.mention} tem atualmente {count} teamkills(s)."
    )

#COMANDO /MEUCONTADOR
@bot.tree.command(name="meucontador", description="Veja quantos teamkills vocÃª jÃ¡ cometeu.")
async def meucontador(interaction: discord.Interaction):
    count = user_counters.get(str(interaction.user.id), 0)
    await interaction.response.send_message(
        f"ğŸ™‹ {interaction.user.mention}, vocÃª tem atualmente {count} tk(s)."
    )

#COMANDO /TOP
@bot.tree.command(name="top", description="Mostra o ranking de usuÃ¡rios com mais teamkills do esquadrÃ£o.")
async def top(interaction: discord.Interaction):
    if not user_counters:
        await interaction.response.send_message("âŒ Ainda nÃ£o hÃ¡ contadores registrados.")
        return

    ranking = sorted(user_counters.items(), key=lambda x: x[1], reverse=True)
    top_text = "ğŸ† **Ranking de Teamkills ELDAR**:\n\n"

    for i, (user_id, count) in enumerate(ranking[:10], start=1):
        user = await bot.fetch_user(int(user_id))
        top_text += f"**{i}.** {user.mention} â€” {count} teamkill(s)\n"

    await interaction.response.send_message(top_text)

#COMANDO /ZERAR
@bot.tree.command(name="zerar", description="Reseta o contador de um usuÃ¡rio (apenas admins).")
@app_commands.describe(usuario="UsuÃ¡rio que vocÃª quer resetar")
@app_commands.default_permissions(administrator=True)
async def zerar(interaction: discord.Interaction, usuario: discord.User):
    # Additional runtime check as fallback
    if not isinstance(interaction.user, discord.Member) or not interaction.user.guild_permissions.administrator:
        await interaction.response.send_message("âŒ VocÃª nÃ£o tem permissÃ£o para usar este comando.", ephemeral=True)
        return

    user_counters[str(usuario.id)] = 0
    save_data()
    await interaction.response.send_message(f"ğŸ”„ O contador de {usuario.mention} foi resetado para 0.")

# TOKEN DISCORD

# Use environment variable for the token
bot_token = os.getenv("DISCORD_BOT_TOKEN")
if bot_token:
    keep_alive() # ğŸ”¥ inicia o servidor web para manter ativo
    bot.run(bot_token)
else:
    print("âŒ DISCORD_BOT_TOKEN nÃ£o encontrado nas variÃ¡veis de ambiente.")
    print("Por favor, configure o token do bot nas configuraÃ§Ãµes de segredos.")
